<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Velastra</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            overflow: hidden;
        }

        body {
            background: #000;
            width: 100vw;
            height: 100vh;
            cursor: none;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Portal that emerges */
        #doorway {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.8s ease;
            z-index: 100;
        }

        #doorway.visible {
            pointer-events: auto;
            opacity: 1;
        }

        #doorway-inner {
            width: 140px;
            height: 180px;
            border: 2px solid rgba(120, 200, 140, 0.6);
            border-radius: 50%;
            background: radial-gradient(ellipse at center, 
                rgba(10, 20, 60, 0.95) 0%, 
                rgba(20, 40, 80, 0.8) 40%,
                rgba(80, 160, 120, 0.3) 80%,
                rgba(120, 200, 140, 0.1) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 
                0 0 40px rgba(120, 200, 140, 0.5),
                0 0 80px rgba(120, 200, 140, 0.3),
                0 0 120px rgba(120, 200, 140, 0.1),
                inset 0 0 40px rgba(10, 30, 60, 0.8);
            animation: portal-pulse 3s ease-in-out infinite;
        }

        @keyframes portal-pulse {
            0%, 100% { 
                box-shadow: 
                    0 0 40px rgba(120, 200, 140, 0.5),
                    0 0 80px rgba(120, 200, 140, 0.3),
                    0 0 120px rgba(120, 200, 140, 0.1),
                    inset 0 0 40px rgba(10, 30, 60, 0.8);
                transform: scale(1);
            }
            50% { 
                box-shadow: 
                    0 0 60px rgba(120, 200, 140, 0.7),
                    0 0 100px rgba(120, 200, 140, 0.4),
                    0 0 150px rgba(120, 200, 140, 0.2),
                    inset 0 0 50px rgba(10, 30, 60, 0.9);
                transform: scale(1.02);
            }
        }

        #doorway-text {
            color: rgba(217, 170, 100, 0.95);
            font-family: 'Georgia', serif;
            font-size: 14px;
            letter-spacing: 4px;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(217, 170, 100, 0.5);
        }

        #doorway-inner:hover {
            background: radial-gradient(ellipse at center, 
                rgba(15, 30, 70, 0.9) 0%, 
                rgba(30, 50, 90, 0.7) 40%,
                rgba(100, 180, 140, 0.4) 80%,
                rgba(140, 220, 160, 0.2) 100%);
            box-shadow: 
                0 0 60px rgba(140, 220, 160, 0.7),
                0 0 100px rgba(140, 220, 160, 0.5),
                0 0 150px rgba(140, 220, 160, 0.2),
                inset 0 0 50px rgba(10, 30, 60, 0.7);
        }

        /* Hint text that fades in */
        #hint {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(106, 155, 204, 0.5);
            font-family: 'Georgia', serif;
            font-size: 14px;
            letter-spacing: 2px;
            opacity: 0;
            transition: opacity 2s ease;
            z-index: 50;
        }

        #hint.visible {
            opacity: 1;
        }

        /* Custom cursor */
        #custom-cursor {
            position: fixed;
            width: 8px;
            height: 8px;
            background: rgba(217, 151, 87, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease, width 0.3s ease, height 0.3s ease, background 0.3s ease;
        }

        #custom-cursor.gathering {
            width: 12px;
            height: 12px;
            background: rgba(217, 151, 87, 1);
            box-shadow: 0 0 20px rgba(217, 151, 87, 0.6);
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="custom-cursor"></div>
    <div id="hint">be still</div>
    <div id="doorway">
        <div id="doorway-inner" onclick="enterVelastra()">
            <span id="doorway-text">Enter</span>
        </div>
    </div>

    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // VELASTRA HOMEPAGE - Recognition Cascade Adapted
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Parameters
        const params = {
            particleCount: 800,
            noiseScale: 0.004,
            fadeAmount: 25,
            stillnessThreshold: 15,      // pixels of movement to count as "moving"
            coherenceThreshold: 0.7,      // threshold to show doorway
            gatheringRadius: 250,         // how close particles need to be
        };

        // State
        let particles = [];
        let mousePos = { x: 0, y: 0 };
        let lastMousePos = { x: 0, y: 0 };
        let stillnessTimer = 0;
        let isStill = false;
        let coherenceLevel = 0;
        let time = 0;
        let doorwayVisible = false;
        let hintShown = false;
        let hintTimer = 0;

        // Audio
        let audioContext = null;
        let oscillator = null;
        let gainNode = null;
        let audioInitialized = false;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // P5.JS SETUP & DRAW
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function setup() {
            let canvas = createCanvas(windowWidth, windowHeight);
            canvas.parent('canvas-container');
            
            mousePos = { x: width / 2, y: height / 2 };
            lastMousePos = { x: width / 2, y: height / 2 };
            
            initializeParticles();
            noCursor();
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }

        function initializeParticles() {
            particles = [];
            for (let i = 0; i < params.particleCount; i++) {
                particles.push(new Particle());
            }
        }

        function draw() {
            // Draw background with radial gradient
            drawBackground();
            
            // Update stillness detection
            updateStillness();
            
            // Update coherence level
            updateCoherence();
            
            // Update audio
            updateAudio();
            
            // Update hint visibility
            updateHint();
            
            // Update doorway visibility
            updateDoorway();
            
            // Update and display particles
            for (let p of particles) {
                p.update();
                p.display();
            }
            
            // Draw witness point glow at cursor when gathering
            if (isStill && stillnessTimer > 30) {
                drawWitnessGlow();
            }
            
            time += 0.01;
        }

        function drawBackground() {
            // Dark void base
            background(0);
            
            // Deep blue radial gradient at edges
            let maxDist = dist(0, 0, width/2, height/2);
            
            for (let r = maxDist; r > maxDist * 0.3; r -= 20) {
                let alpha = map(r, maxDist * 0.3, maxDist, 0, 40);
                let blue = map(r, maxDist * 0.3, maxDist, 20, 60);
                noStroke();
                fill(10, 20, blue, alpha);
                ellipse(width/2, height/2, r * 2);
            }
        }

        function drawWitnessGlow() {
            let intensity = map(stillnessTimer, 30, 200, 0, 1);
            intensity = constrain(intensity, 0, 1);
            
            // Pulsing glow
            let pulseSize = 30 + sin(time * 2) * 10;
            pulseSize *= intensity;
            
            for (let r = pulseSize; r > 0; r -= 5) {
                let alpha = map(r, pulseSize, 0, 0, 30 * intensity);
                fill(217, 151, 87, alpha);
                noStroke();
                ellipse(mousePos.x, mousePos.y, r * 2);
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STILLNESS & COHERENCE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function updateStillness() {
            let movement = dist(mousePos.x, mousePos.y, lastMousePos.x, lastMousePos.y);
            
            if (movement < params.stillnessThreshold) {
                stillnessTimer++;
                if (stillnessTimer > 20) {
                    isStill = true;
                }
            } else {
                stillnessTimer = max(0, stillnessTimer - 5); // Gradual decrease
                if (stillnessTimer < 10) {
                    isStill = false;
                }
            }
            
            lastMousePos = { x: mousePos.x, y: mousePos.y };
        }

        function updateCoherence() {
            if (!isStill) {
                coherenceLevel = max(0, coherenceLevel - 0.005);
                return;
            }
            
            // Calculate average distance of particles from cursor
            let totalDist = 0;
            let nearCount = 0;
            
            for (let p of particles) {
                let d = dist(p.pos.x, p.pos.y, mousePos.x, mousePos.y);
                if (d < params.gatheringRadius) {
                    nearCount++;
                }
                totalDist += d;
            }
            
            let avgDist = totalDist / particles.length;
            let maxPossibleDist = dist(0, 0, width, height) / 2;
            
            // Coherence based on how many particles are near and overall clustering
            let proximityRatio = nearCount / particles.length;
            let clusteringRatio = 1 - (avgDist / maxPossibleDist);
            
            let targetCoherence = (proximityRatio * 0.7 + clusteringRatio * 0.3);
            
            // Gradually approach target
            coherenceLevel += (targetCoherence - coherenceLevel) * 0.02;
            coherenceLevel = constrain(coherenceLevel, 0, 1);
        }

        function updateHint() {
            hintTimer++;
            
            // Show hint after a few seconds if user hasn't been still
            if (hintTimer > 180 && !hintShown && coherenceLevel < 0.3) {
                document.getElementById('hint').classList.add('visible');
                hintShown = true;
            }
            
            // Hide hint once they start gathering
            if (coherenceLevel > 0.4) {
                document.getElementById('hint').classList.remove('visible');
            }
        }

        function updateDoorway() {
            let doorway = document.getElementById('doorway');
            
            if (coherenceLevel > params.coherenceThreshold && !doorwayVisible) {
                doorwayVisible = true;
                doorway.classList.add('visible');
            } else if (coherenceLevel < params.coherenceThreshold * 0.7 && doorwayVisible) {
                doorwayVisible = false;
                doorway.classList.remove('visible');
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // AUDIO
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function initAudio() {
            if (audioInitialized) return;
            
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create oscillator for ambient tone
                oscillator = audioContext.createOscillator();
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(136.1, audioContext.currentTime); // Om frequency
                
                // Create gain node for volume control
                gainNode = audioContext.createGain();
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                
                // Create filter for warmth
                let filter = audioContext.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(400, audioContext.currentTime);
                
                // Connect nodes
                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();
                audioInitialized = true;
            } catch (e) {
                console.log('Audio not available');
            }
        }

        function updateAudio() {
            if (!audioInitialized || !gainNode) return;
            
            // Volume based on stillness and coherence
            let targetVolume = 0;
            
            if (isStill && stillnessTimer > 30) {
                targetVolume = map(coherenceLevel, 0, 1, 0, 0.15);
                
                // Add slight frequency modulation based on coherence
                let targetFreq = map(coherenceLevel, 0, 1, 136.1, 272.2); // Rise an octave
                oscillator.frequency.setTargetAtTime(targetFreq, audioContext.currentTime, 0.5);
            }
            
            gainNode.gain.setTargetAtTime(targetVolume, audioContext.currentTime, 0.3);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PARTICLE CLASS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        class Particle {
            constructor() {
                this.pos = createVector(random(width), random(height));
                this.vel = createVector(0, 0);
                this.acc = createVector(0, 0);
                
                this.maxSpeed = random(1, 2.5);
                this.baseOpacity = random(20, 60);
                this.opacity = this.baseOpacity;
                this.size = random(1, 3);
                
                // Start with cool uncertain colors
                this.hue = random(200, 240); // Blue range
                this.baseHue = this.hue;
            }

            update() {
                let distToCursor = dist(this.pos.x, this.pos.y, mousePos.x, mousePos.y);
                
                // Noise-driven wandering (always present)
                let noiseAngle = noise(
                    this.pos.x * params.noiseScale, 
                    this.pos.y * params.noiseScale, 
                    time
                ) * TWO_PI * 2;
                let noiseForce = p5.Vector.fromAngle(noiseAngle);
                noiseForce.mult(0.2);
                this.acc.add(noiseForce);
                
                if (isStill && stillnessTimer > 20) {
                    // GATHERING MODE - attracted to cursor
                    let gatherStrength = map(stillnessTimer, 20, 150, 0.02, 0.15);
                    gatherStrength = constrain(gatherStrength, 0, 0.15);
                    
                    if (distToCursor < params.gatheringRadius * 2) {
                        let toCursor = p5.Vector.sub(
                            createVector(mousePos.x, mousePos.y), 
                            this.pos
                        );
                        toCursor.setMag(gatherStrength);
                        this.acc.add(toCursor);
                        
                        // Increase opacity and shift color toward gold
                        let proximity = map(distToCursor, params.gatheringRadius * 2, 0, 0, 1);
                        proximity = constrain(proximity, 0, 1);
                        
                        this.opacity = this.baseOpacity + proximity * 150;
                        this.hue = lerp(this.baseHue, 40, proximity * coherenceLevel); // Shift toward gold
                    }
                } else {
                    // DISPERSING MODE - slight repulsion and more chaos
                    if (distToCursor < 150) {
                        let fromCursor = p5.Vector.sub(this.pos, createVector(mousePos.x, mousePos.y));
                        fromCursor.setMag(0.3);
                        this.acc.add(fromCursor);
                    }
                    
                    // Return to base state
                    this.opacity = lerp(this.opacity, this.baseOpacity, 0.05);
                    this.hue = lerp(this.hue, this.baseHue, 0.02);
                }
                
                // Physics
                this.vel.add(this.acc);
                this.vel.limit(this.maxSpeed);
                this.pos.add(this.vel);
                this.acc.mult(0);
                
                // Wrap edges
                if (this.pos.x < 0) this.pos.x = width;
                if (this.pos.x > width) this.pos.x = 0;
                if (this.pos.y < 0) this.pos.y = height;
                if (this.pos.y > height) this.pos.y = 0;
            }

            display() {
                colorMode(HSB, 360, 100, 100, 255);
                let saturation = map(this.opacity, 20, 200, 30, 70);
                let brightness = map(this.opacity, 20, 200, 40, 90);
                
                fill(this.hue, saturation, brightness, this.opacity);
                noStroke();
                ellipse(this.pos.x, this.pos.y, this.size);
                colorMode(RGB, 255);
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // EVENT HANDLERS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function mouseMoved() {
            mousePos = { x: mouseX, y: mouseY };
            
            // Update custom cursor
            let cursor = document.getElementById('custom-cursor');
            cursor.style.left = mouseX + 'px';
            cursor.style.top = mouseY + 'px';
            
            if (isStill && coherenceLevel > 0.3) {
                cursor.classList.add('gathering');
            } else {
                cursor.classList.remove('gathering');
            }
            
            // Initialize audio on first interaction
            if (!audioInitialized) {
                initAudio();
            }
        }

        function mousePressed() {
            // Initialize audio on click if not already
            if (!audioInitialized) {
                initAudio();
            }
        }

        function enterVelastra() {
            // Transition effect
            document.body.style.transition = 'opacity 1s ease';
            document.body.style.opacity = '0';
            
            // Navigate after fade
            setTimeout(() => {
                // For now, just alert - replace with actual navigation
                alert('Welcome to Velastra.\n\nThis is where the rest of the world will live.\n\nğŸ’œâœ¨');
                document.body.style.opacity = '1';
            }, 1000);
        }

        // Touch support
        function touchMoved() {
            if (touches.length > 0) {
                mousePos = { x: touches[0].x, y: touches[0].y };
                
                let cursor = document.getElementById('custom-cursor');
                cursor.style.left = touches[0].x + 'px';
                cursor.style.top = touches[0].y + 'px';
            }
            return false;
        }
    </script>
</body>
</html>
